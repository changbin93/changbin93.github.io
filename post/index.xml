<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://changbin93.github.io/post/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Sep 2020 03:20:34 +0800</lastBuildDate>
    
	<atom:link href="https://changbin93.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Blog</title>
      <link>https://changbin93.github.io/post/explain%E5%8F%8A%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sat, 12 Sep 2020 03:20:34 +0800</pubDate>
      
      <guid>https://changbin93.github.io/post/explain%E5%8F%8A%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description></description>
    </item>
    
    <item>
      <title>MySQL索引数据结构</title>
      <link>https://changbin93.github.io/post/mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 12 Jul 2020 02:58:11 +0800</pubDate>
      
      <guid>https://changbin93.github.io/post/mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>MySQL索引底层数据结构与算法  什么是索引
 ==索引==是帮助MySQL高效获取数据的==排好序==的==数据结构==
那么有哪些数据结构可以做索引呢？
 二叉树 红黑树 Hash表 B-Tree  二叉搜索树的问题在于如果插入的数据是递增的话，就会形成一个链表结构，这样查找的效率就大大降低。
那用二叉平衡树，比如红黑树能解决吗，红黑树不会产生上述现象，但是由于红黑树的非叶子结点下只能存储左右两个结点，如果数据量很大，红黑树的树高会很高，这样需要对磁盘进行多次IO，效率依然不高。
有没有什么数据结构能解决？首先我们来看B树。
 B-Tree
  叶子结点具有相同的深度，叶子结点的指针为空 所有索引元素不重复 叶子结点中的数据索引从左到右递增排列  那么为什么B树依然不是最好的选择呢？
MySQL的数据都是存放在磁盘上的，索引也是，mysql每进行一次磁盘IO只能获取一页的数据，一页在MySQL中大概是16KB，一个索引的数据越大，那么一页能存储的索引就越少，而B树每个索引存储了数据的全部信息，这就意味着每一页存储的索引变少了。于是对B树进行了改进。
 B+ 树
  非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引 叶子结点包含所有索引字段 叶子结点用指针链接，提高区间访问的性能  B+ 树的非叶子结点能存放更对索引，这样树的高度就降低了，进行磁盘IO的次数也变少，大大提高了搜索效率。
最后来说说hash，hash也是一种非常高效的数据结构，对索引的key进行一次hash计算就能定位出数据存储的位置，很多时候hash索引要比B+树索引更高效。但是hash不支持范围查询，并且有hash冲突问题。
MyISAM存储引擎索引实现 MyISAM索引文件和数据文件是分离的(非聚集索引)
叶子结点上只存储了索引字段和一个指针，指针指向在另一个文件中的数据。
InnoDB存储引擎索引实现(聚集索引)  表数据文件本身就是按B+树组织的一个索引结构文件 叶子结点包含了完整的数据记录   为什么建议InnoDB表必须建主键，并且推荐使用整形的自增主键
 如果设置了主键，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增)。
如果表使用自增主键 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，主键的顺序按照数据记录的插入顺序排列，自动有序。当一页写满，就会自动开辟一个新的页
如果使用非自增主键（如果身份证号或学号等） 由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。
 为什么非主键索引结构叶子节点存储的是主键值?
 减少了出现行移动或者数据页分裂时二级索引的维护工作（当数据需要更新的时候，二级索引不需要修改，只需要修改聚簇索引，一个表只能有一个聚簇索引，其他的都是二级索引，这样只需要修改聚簇索引就可以了，不需要重新构建二级索引）
 联合索引的底层存储结构长什么样？
 </description>
    </item>
    
  </channel>
</rss>